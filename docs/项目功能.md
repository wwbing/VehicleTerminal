# 项目核心功能分析

本文档旨在梳理和分析“智能车载终端系统”的核心功能实现，特别是语音控制的完整链路。

## 语音控制功能 (Voice Control) - 完整工作链路

语音控制是本项目的核心人机交互方式之一。其实现横跨了硬件驱动、音频处理、网络通信和应用逻辑等多个层面。以下是用户按下语音键到系统执行指令的完整步骤：

### 1. 硬件监听与触发
-   **监听单元**: `SpeechRecognition` 类。
-   **触发方式**: 系统启动后，`SpeechRecognition` 会通过 `initKeyRead()` 打开设备文件 `/dev/key`，这是一个代表特定物理按键的字符设备。
-   **轮询检测**: 通过一个500ms周期的 `QTimer`，在 `timer_timerout()` 槽函数中反复调用 `readKeyValue()` 读取按键状态。
-   **工作模式**: 这是一种简单高效的**硬件轮询**模式，适用于没有中断或应用层事件驱动的简单按键。

### 2. 本地音频录制
-   **开始录音**: 当 `timer_timerout()` 检测到按键被按下（`keyValue == 240`），它会调用 `startRecord()` 函数。
-   **录音引擎**: `QAudioRecorder` 类负责处理底层的音频采集。
-   **音频参数**:
    -   采样率 (Sample Rate): **16000 Hz**
    -   通道数 (Channels): 1 (单声道)
    -   格式 (Format): `.wav`
-   **输出文件**: 录制的音频被实时保存在项目根目录下的 `record.wav` 文件中。
-   **结束录音**: 当检测到按键松开时，调用 `stopRecord()`，`QAudioRecorder` 停止录音，并发出 `RecordFinished()` 信号。

### 3. 音频上传与云端识别
-   **信号接收**: `MainWindow` 类通过 `connect` 捕获 `SpeechRecognition` 发出的 `RecordFinished()` 信号，并调用其 `on_handleRecord()` 槽函数。
-   **文件处理**:
    1.  `on_handleRecord()` 首先读取本地的 `record.wav` 文件。
    2.  将原始的WAV文件数据进行 **Base64 编码**。
-   **API 请求**:
    -   **服务商**: 百度智能云语音技术。
    -   **接口地址**: `http://vop.baidu.com/server_api`
    -   **请求构建**: 将Base64编码后的音频数据，连同采样率、格式、用户ID (`cuid`)、以及访问令牌 (`token`) 等参数，构造成一个 **JSON 对象**。
    -   **网络发送**: 使用 `QNetworkAccessManager` 将此JSON对象作为HTTP POST请求的主体（Body）发送到百度API服务器。

### 4. 指令解析与分发
-   **API 响应**: 当百度服务器返回识别结果后，`MainWindow` 的 `getSpeechResult(QNetworkReply *reply)` 槽函数被触发。
-   **结果提取**: 该函数负责解析返回的JSON数据，提取出识别到的核心文本字符串（例如：“播放音乐”）。
-   **指令匹配**: 通过一长串 `if-else if` 语句，程序将识别出的文本与预设的命令关键词进行模糊匹配（使用 `contains()` 方法）。
-   **信号分发**: 一旦匹配成功，`MainWindow` 会通过 `emit` 发出一个对应的**Qt信号**，例如 `SendCommandToMusic(MUSIC_COMMAND_PLAY)`。这些信号是抽象的，只负责传递指令类型，而不关心具体实现。

### 5. 执行最终操作
-   **模块化接收**: 在 `MainWindow` 的构造函数中，这些指令信号已经与具体功能模块的槽函数进行了绑定。
    -   `connect(this, SIGNAL(SendCommandToMusic(int)), musicPlayer, SLOT(on_handleCommand(int)));`
    -   `connect(this, SIGNAL(SendCommandToMap(int)), baiduMap, SLOT(on_handleCommand(int)));`
-   **最终执行**: 相应模块（如 `MusicPlayer`）的 `on_handleCommand(int)` 槽函数被调用，它会根据传入的指令代码（如 `MUSIC_COMMAND_PLAY`），执行最终的操作，如播放音乐、切换歌曲或打开地图界面。

---
## 链路总结

硬件按键 -> `SpeechRecognition` (轮询) -> `QAudioRecorder` (录音) -> `MainWindow` (读文件 & Base64编码) -> `QNetworkAccessManager` (POST到百度云) -> `MainWindow` (接收并解析JSON) -> `if/else` (匹配指令) -> `emit` (发送指令信号) -> `MusicPlayer`等模块 (执行操作)。

这个设计模式将**UI/指令中心 (`MainWindow`)** 与 **具体功能模块 (`MusicPlayer`, etc.)** 解耦，使得系统易于扩展新的语音指令和功能模块。 

## 环境监控 (Environment Monitor) - 工作链路

环境监控模块负责采集和展示车内及周围环境的实时数据，如温湿度、光照强度等。

### 1. UI触发与数据显示
-   **交互入口**: 用户在主界面 (`MainWindow`) 点击“环境监控”按钮。
-   **信号/槽**: `MainWindow` 中的 `on_pushButton_monitor_clicked()` 槽函数被触发。
-   **界面切换**: 该函数将主界面的 `QStackedWidget` 切换到 `monitorPage`。
-   **数据显示**: `Monitor` 类会定时更新从传感器读取到的数据，并通过信号将其传递给 `MainWindow`，`MainWindow` 再将这些数据显示在 `monitorPage` 界面的 `ui->label_temp`、`ui->label_hum` 等控件上。

### 2. 传感器数据采集
-   **核心模块**: `Monitor` 类，它是一个单例，确保系统中只有一个实例在访问硬件。
-   **定时轮询**: `Monitor` 类在其构造函数中启动一个 `QTimer`，每2秒触发一次 `on_timer_timeout()` 槽函数。
-   **数据读取**: 在 `on_timer_timeout()` 中，会依次调用以下函数来读取不同传感器的数据：
    -   `getTempAndHum()`:
        -   打开设备文件 `/dev/dht11`。
        -   向该文件写入一个任意字符（作为触发信号）。
        -   立即从文件读取4个字节的数据，分别代表湿度的整数和小数部分、温度的整数和小数部分。
        -   这是一个典型的**字符设备驱动**交互模式。
    -   `getIllumination()`:
        -   通过 `openI2cDevice()` 打开 I2C 总线设备（例如 `/dev/i2c-1`）。
        -   使用 `ioctl` 系统调用设置从设备地址（`0x5c`），这是与BH1750光照传感器通信的地址。
        -   向传感器写入一个启动测量的命令（`0x01`）。
        -   等待200毫秒让传感器完成转换。
        -   从设备读取2个字节的数据，并将其合成为一个16位的照度值。
-   **数据分发**: 读取到新数据后，`Monitor` 类会发出 `sendTempAndHum(int, int)` 和 `sendIllumination(int)` 信号。
-   **UI更新**: `MainWindow` 接收到这些信号后，调用对应的槽函数（如 `on_recvTempAndHum`），更新UI上的温湿度和光照度显示。

---

## 音乐播放 (Music Player) - 工作链路

### 1. 播放器初始化
-   **核心模块**: `MusicPlayer` 类。
-   **网络管理器**: 拥有一个 `QNetworkAccessManager` 实例，用于后续的网络请求。
-   **播放列表**: 拥有一个 `QMediaPlaylist` 实例，用于管理歌曲列表。
-   **播放引擎**: 拥有一个 `QMediaPlayer` 实例，负责解码和播放音频。
-   **初始化流程**:
    1.  `MusicPlayer` 实例化后，会立即调用 `getPlayList()` 函数。
    2.  `getPlayList()` 向一个硬编码的服务器地址 (`http://192.168.1.137/music/playlist.json`) 发送HTTP GET请求，以获取歌曲列表。
    3.  接收到JSON响应后，`on_getPlayList()` 槽函数被触发，它会解析JSON，提取歌曲名称和URL，并将它们添加到 `QMediaPlaylist` 中。
    4.  同时，歌曲名称会被添加到UI界面（`musicPage`）的 `QListWidget` 中，供用户选择。

### 2. 用户交互与播放控制
-   **播放/暂停**: 用户点击播放按钮，触发 `on_pushButton_play_clicked()`。该函数会检查 `QMediaPlayer` 的当前状态，并调用 `play()` 或 `pause()`。
-   **下一首/上一首**: 用户点击相应按钮，直接调用 `QMediaPlaylist` 的 `next()` 或 `previous()` 方法。`QMediaPlayer` 会自动播放播放列表中的新曲目。
-   **点击列表播放**: 用户双击 `QListWidget` 中的某一项，会触发 `on_listWidget_itemDoubleClicked()`。该函数会获取被点击项的行号，然后调用 `QMediaPlaylist` 的 `setCurrentIndex()` 方法来切换到对应的歌曲并自动播放。
-   **进度条更新**: `QMediaPlayer` 在播放时会持续发出 `positionChanged(qint64)` 信号。`MusicPlayer` 类捕获此信号，并据此更新UI上的进度条。

---

## 地图导航 (Map Navigation) - 工作链路

地图模块的核心是展示从GPS硬件获取的实时位置。

### 1. GPS数据读取
-   **底层接口**: `gps.c` 和 `gps.h` 文件封装了对串口通信的底层操作。
    -   `gps_init()`: 打开并配置串口设备 `/dev/ttymxc2`。
    -   `gps_read_data()`: 从串口读取原始的NMEA 0183格式的GPS数据。
    -   `gps_parse_data()`: 解析NMEA语句（特别是 `$GPGGA`），提取出经纬度等关键信息。
    -   `gps_close()`: 关闭串口。
-   **数据封装**: `BaiduMap` 类是地图功能的上层封装。
-   **定时读取**: `BaiduMap` 在其构造函数中启动一个 `QTimer`，每3秒触发一次 `on_timer_timeout()`。
-   **读取与解析**: `on_timer_timeout()` 调用 `gps_read_data()` 和 `gps_parse_data()`，获取解析后的经纬度坐标。

### 2. UI展示
-   **核心组件**: 地图展示依赖于 `map.html` 文件，它是一个本地的HTML页面，内置了百度地图的JavaScript API。
-   **数据显示**: `BaiduMap` 类并不直接绘制地图，而是通过 `QWebEngineView` 控件加载 `map.html`。
-   **JS交互**: 当 `BaiduMap` 通过C++代码获取到新的GPS坐标后，它会执行一段JavaScript代码来调用 `map.html` 中预定义的 `showLocation(longitude, latitude)` 函数。
-   **地图更新**: `showLocation` JS函数接收到新的坐标后，会调用百度地图API在网页上的地图中更新标记（Marker）的位置，从而实现位置的实时显示。
-   **C++ <-> JS 通信**: 这是典型的Qt与Web混合编程的应用，通过 `QWebEngineView::page()->runJavaScript()` 方法实现C++对JavaScript的调用。

---

## 天气查询 (Weather Forecast) - 工作链路

天气模块通过第三方网络API获取数据并展示。

### 1. UI触发
-   用户在主界面点击“天气”按钮，`MainWindow` 的 `on_pushButton_weather_clicked()` 被触发，切换到 `weatherPage`。
-   同时，`MainWindow` 会调用 `Weather` 单例类的 `getWeatherInfo()` 方法来启动数据获取流程。

### 2. 网络数据获取
-   **核心模块**: `Weather` 类。
-   **API接口**: 向心知天气API (`https://api.seniverse.com/v3/...`) 发送HTTP GET请求。
-   **请求参数**: 请求的URL中包含了API密钥、地理位置（`beijing`）和单位（`c`）等参数。
-   **数据接收**: `Weather` 类中的 `on_getWeatherInfo(QNetworkReply *reply)` 槽函数负责接收网络响应。

### 3. 数据解析与UI更新
-   **JSON解析**: `on_getWeatherInfo()` 函数负责解析返回的JSON数据，提取出城市、天气现象、温度等信息。
-   **信号分发**: 解析成功后，`Weather` 类会发出 `sendWeatherInfo(QString, QString, QString)` 信号，将天气数据传递出去。
-   **UI更新**: `MainWindow` 接收到此信号后，在 `on_recvWeatherInfo` 槽函数中，将数据显示在 `weatherPage` 上的各个 `QLabel` 控件中。 