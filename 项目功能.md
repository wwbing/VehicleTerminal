# 项目核心功能分析

本文档旨在梳理和分析“智能车载终端系统”的核心功能实现，特别是语音控制的完整链路。

## 语音控制功能 (Voice Control) - 完整工作链路

语音控制是本项目的核心人机交互方式之一。其实现横跨了硬件驱动、音频处理、网络通信和应用逻辑等多个层面。以下是用户按下语音键到系统执行指令的完整步骤：

### 1. 硬件监听与触发
-   **监听单元**: `SpeechRecognition` 类。
-   **触发方式**: 系统启动后，`SpeechRecognition` 会通过 `initKeyRead()` 打开设备文件 `/dev/key`，这是一个代表特定物理按键的字符设备。
-   **轮询检测**: 通过一个500ms周期的 `QTimer`，在 `timer_timerout()` 槽函数中反复调用 `readKeyValue()` 读取按键状态。
-   **工作模式**: 这是一种简单高效的**硬件轮询**模式，适用于没有中断或应用层事件驱动的简单按键。

### 2. 本地音频录制
-   **开始录音**: 当 `timer_timerout()` 检测到按键被按下（`keyValue == 240`），它会调用 `startRecord()` 函数。
-   **录音引擎**: `QAudioRecorder` 类负责处理底层的音频采集。
-   **音频参数**:
    -   采样率 (Sample Rate): **16000 Hz**
    -   通道数 (Channels): 1 (单声道)
    -   格式 (Format): `.wav`
-   **输出文件**: 录制的音频被实时保存在项目根目录下的 `record.wav` 文件中。
-   **结束录音**: 当检测到按键松开时，调用 `stopRecord()`，`QAudioRecorder` 停止录音，并发出 `RecordFinished()` 信号。

### 3. 音频上传与云端识别
-   **信号接收**: `MainWindow` 类通过 `connect` 捕获 `SpeechRecognition` 发出的 `RecordFinished()` 信号，并调用其 `on_handleRecord()` 槽函数。
-   **文件处理**:
    1.  `on_handleRecord()` 首先读取本地的 `record.wav` 文件。
    2.  将原始的WAV文件数据进行 **Base64 编码**。
-   **API 请求**:
    -   **服务商**: 百度智能云语音技术。
    -   **接口地址**: `http://vop.baidu.com/server_api`
    -   **请求构建**: 将Base64编码后的音频数据，连同采样率、格式、用户ID (`cuid`)、以及访问令牌 (`token`) 等参数，构造成一个 **JSON 对象**。
    -   **网络发送**: 使用 `QNetworkAccessManager` 将此JSON对象作为HTTP POST请求的主体（Body）发送到百度API服务器。

### 4. 指令解析与分发
-   **API 响应**: 当百度服务器返回识别结果后，`MainWindow` 的 `getSpeechResult(QNetworkReply *reply)` 槽函数被触发。
-   **结果提取**: 该函数负责解析返回的JSON数据，提取出识别到的核心文本字符串（例如：“播放音乐”）。
-   **指令匹配**: 通过一长串 `if-else if` 语句，程序将识别出的文本与预设的命令关键词进行模糊匹配（使用 `contains()` 方法）。
-   **信号分发**: 一旦匹配成功，`MainWindow` 会通过 `emit` 发出一个对应的**Qt信号**，例如 `SendCommandToMusic(MUSIC_COMMAND_PLAY)`。这些信号是抽象的，只负责传递指令类型，而不关心具体实现。

### 5. 执行最终操作
-   **模块化接收**: 在 `MainWindow` 的构造函数中，这些指令信号已经与具体功能模块的槽函数进行了绑定。
    -   `connect(this, SIGNAL(SendCommandToMusic(int)), musicPlayer, SLOT(on_handleCommand(int)));`
    -   `connect(this, SIGNAL(SendCommandToMap(int)), baiduMap, SLOT(on_handleCommand(int)));`
-   **最终执行**: 相应模块（如 `MusicPlayer`）的 `on_handleCommand(int)` 槽函数被调用，它会根据传入的指令代码（如 `MUSIC_COMMAND_PLAY`），执行最终的操作，如播放音乐、切换歌曲或打开地图界面。

---
## 链路总结

硬件按键 -> `SpeechRecognition` (轮询) -> `QAudioRecorder` (录音) -> `MainWindow` (读文件 & Base64编码) -> `QNetworkAccessManager` (POST到百度云) -> `MainWindow` (接收并解析JSON) -> `if/else` (匹配指令) -> `emit` (发送指令信号) -> `MusicPlayer`等模块 (执行操作)。

这个设计模式将**UI/指令中心 (`MainWindow`)** 与 **具体功能模块 (`MusicPlayer`, etc.)** 解耦，使得系统易于扩展新的语音指令和功能模块。 